%%This is a very basic article template.
%%There is just one section and two subsections.

\documentclass[11pt,a4paper,oneside]{report}

\usepackage{listings}
\usepackage{fullpage}


\usepackage{listings}
\usepackage{color}
\usepackage{textcomp}
\definecolor{listinggray}{gray}{0.9}
\definecolor{lbcolor}{rgb}{0.9,0.9,0.9}
\lstset{
  backgroundcolor=\color{lbcolor},
  tabsize=4,
  rulecolor=,
  language=C,
  basicstyle=\scriptsize,
  upquote=true,
  aboveskip={1.5\baselineskip},
  columns=fixed,
  showstringspaces=false,
  extendedchars=true,
  breaklines=true,
  prebreak = \raisebox{0ex}[0ex][0ex]{\ensuremath{\hookleftarrow}},
  frame=single,
  showtabs=false,
  showspaces=false,
  showstringspaces=false,
  identifierstyle=\ttfamily,
  keywordstyle=\color[rgb]{0,0,1},
  commentstyle=\color[rgb]{0.133,0.545,0.133},
  stringstyle=\color[rgb]{0.627,0.126,0.941},
}

\begin{document}
\lstset{language=C}
\setcounter{secnumdepth}{1}


\title{\center{Data Networks project}}
\author{Group 7: \\ Igor Stassiy, Kirill Afanasev,Sanjar Karaev}
\date{\today}
\maketitle

\section*{Introduction}

  The problem - design a protocol which provides reliable service for
  in-order delivery of messages between hosts in multi-host networks with
  different topologies.  \\
  
  Assumptions:
  \begin{enumerate}
    \item In the network hosts and links do not fail
    \item The links have tendency to loose and corrupt frames
    \item Frames can arrive out of order
    \item The links have varying capacities and MTU
    \item Nodes are only aware of their immediate neighbors at the beginning
    \item Total number of hosts is at most 256 and their addresses are in range
    0-255
    \item The minimal possible MTU is 96 bytes
    \item The maximal possible message size generated by the application layer 
    is at most 10240 bytes 
  \end{enumerate}
  
\section*{Protocol Layers}
Our implementation consists of three layers - transport, network
and datalink layers. All of the layers are unaware of the message format of
the other and exchange the information only via an API described below. We
introduce a fixed API as well as a way to signal between layers, for example
telling transport layer that a congestion occured. This design allows to
easily extend functionality of layers.\\

\noindent \textbf{Transport layer}: \\
The purpose of this layer is ensuring that the messages generated by the
application layer are delivered to the host in the correct order and in full.
It also uses flow control so that the receiver is not overwhelmed using a
sliding window for controlling messages to be sent. Both sender and receiver 
maintain a buffer of specified size in order to maintain the order of messages 
passed to the application layer.

Using ideas from IPv6, our protocol ensures that the messages are fragmented
only at the endpoints. Fragmentation and reassembly is managed entirely in the
transport layer. On message loss, only not acknowledged fragments are
retransmitted to save the bandwidth. Acknowledgements are used for signalling
that the whole range of fragments is received, which also saves the bandwidth
and avoids acknowledging separate fragments.
    
Services provided by the layer:
\begin{enumerate}
  \item Reliably delivers a packet from one host to another, avoiding
   packet loss, reordering and corruption.
   \item Accepting messages from application layer and passing down to the
   network layer
\end{enumerate}
    \newpage
    Top level API:  
  \begin{lstlisting}
  // initialize transport layer 
  void init_transport();
  
  // write incoming message from network layer to transport layer
  void read_transport(PACKETKIND kind, uint16_t len, CnetAddr src, PACKET packet);
  
  // read outgoing message from application to transport layer
  void write_transport(CnetEvent ev, CnetTimerID timer, CnetData data);
  
  // signal transport layer
  void signal_transport(SIGNALKIND sg, SIGNALDATA data);
  \end{lstlisting}
   
\noindent \textbf{Network layer}: \\
The purpose of this layer is determining routing and discovering of the
network. When the transport layer has a message to sent, it requests the
network layer for the propagation delay and MTU size along the best possible
path. 

At the stage of neighbor discovery, the network layer advertises itself to other
nodes and based on the answers received and their arrival time builds a routing
table.

Services provided by the layer:
\begin{enumerate}
  \item Determines the routing information for a host
  \item Determines lowest cost path from sender to receiver based on some metric
  (MTU, propagation delay etc.)
  \item Determines propagation delay for routes
  \item Passing message up to the transport layer and down to the datalink layer
\end{enumerate}
    
Top level API:
    
   \begin{lstlisting}
  // initialize network layer
  void init_network() 
  
  // detect fragmentation size for the way to specified address
  int get_mtu(CnetAddr dest);
  
  // get propagation delay for specified address
  int get_propagation_delay(CnetAddr dest);
  
  // read an incoming message from datalink to network layer
  void read_network(int link, DATAGRAM dtg);
  
  // write an outgoing packet into network layer
  void write_network(PACKETKIND kind, CnetAddr dest, uint16_t len, char* pkt);

  // signal network layer
  void signal_network(SIGNALKIND sg, SIGNALDATA data);

  \end{lstlisting}  
            
\noindent \textbf{Datalink layer}: \\
The purpose of this layer is verifying that the datagram arrived is not
corrupted by computing the checksum and passing the datagram further to
the network layer. The layer also maintains a datagram dispatch queue 
and sends the datagrams back to back to the link.
    
    Services provided by the layer:
    \begin{enumerate}
      \item Accepting a datagram from network layer
      \item Passing the datagram up to the network layer 
    \end{enumerate}
    \newpage
    Top level API:

    
  \begin{lstlisting}
  // initialize datalink layer
  void init_datalink();
  
  // read an incoming frame into datalink layer
  void read_datalink(CnetEvent event, CnetTimerID timer, CnetData data);
  
  // write an outcoming frame into datalink layer
  void write_datalink(int link, char *datagram, uint32_t length);
  
  // signal transport layer
  void signal_datalink(SIGNALKIND sg, SIGNALDATA data);
  \end{lstlisting} 
 
\section*{Data exchange format}

We define the following basic transfer units: Message, Packet, Datagram.
Every unit encapsulates data, which is the unit from the layer above and header, 
which is the information added by the current layer. 

Kinds of packet and datagram:

    \begin{lstlisting}
    typedef enum {
        ACK = 1, NACK = 2, DATA = 4, LASTSGM = 8,   // transport layer
        DISCOVER = 16, ROUTING = 32, TRANSPORT = 64 // network layer
    } PACKETKIND;
    \end{lstlisting}
    
Kinds of signals used:

    \begin{lstlisting}
    typedef enum {
        CONGESTION = 1
    } SIGNALKIND;
    \end{lstlisting}

Transfer unit of application layer:
    \begin{lstlisting}
      char msg[MAX_MESSAGE_SIZE]; // message generated by the application layer
    \end{lstlisting}
  
Transfer unit of transport layer:
       
    \begin{lstlisting}
    typedef struct {
      uint8_t seqno; // datagram sequence number
      uint8_t segid; // segment sequence number
      uint8_t ackseqno; // piggybacked ack sequence number
      uint8_t acksegid; // piggybacked ack segment number
      char msg[MAX_MESSAGE_SIZE]; // encapsulated application layer message
    } PACKET;
    \end{lstlisting}
  
Transfer unit of network layer and datalink layers:   
    
    \begin{lstlisting}
    typedef struct {
      uint8_t src;       // source address
      uint8_t dest;      // destination address
      uint8_t kind;      // packet kind
      uint16_t length;   // length of payload
      uint16_t checksum;  // checksum of entire datagram
      char payload[MAXFRAMESIZE]; // encapsulated packet
    } DATAGRAM;
   \end{lstlisting}
   
\section*{Flow control and fragmentation}   

\section*{Routing}
  
The routing algorithm we implement is based upon the AODV (Ad-hoc On-demand
Distance Vector). Every node has links to its neighbours, but in order to
discover them it broadcasts to all its links and waits for replies. The nodes
are initially unaware of other nodes in the network. All nodes maintain a routing 
table and a sent datagram history table. The former includes entries for all
destinations already discovered by the node. For every discovered destination it also contains 
the entry for the first neighbour to contact. The latter contains entries 
for discovery requests that the node has received so far. This serves to 
discard duplicate requests. Whenever a node needs to send a datagram it first 
contacts its routing table and in case there is an entry for the destination
it forwards the datagram to the corresponding link. If the destination is not
in the routing table then the node broadcasts the request to all its
neighbours. When a node receives a discovery request it looks it up in its
history table. If there is an existing entry for this request it is discarded.
Otherwise if the node knows a path to the destination it sends a reply to the
source. If it does not know how to get to destination it increments the hop
of the request and rebroadcasts it to all its links. Then it adds a new entry to
its history table which corresponds to the processed request. After a path to
the destination is discovered reply packets are sent back to the destination
in the reverse order.
\section*{Summary}

\end{document}