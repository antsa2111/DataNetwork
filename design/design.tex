%%This is a very basic article template.
%%There is just one section and two subsections.


\documentclass{book}

\usepackage{listings}

\begin{document}
\lstset{language=C}


\title{\center{Data Networks project}}
\author{Group 7: \\ Igor Stassiy, Kirill Afanasev,Sanjar Karaev}
\date{\today}
\maketitle

\section{Introduction}





	The problem - design a protocol which provides reliable service for
	in order delivering of messages between hosts in multihost networks with
	different topologies.
	%-editor "echo %f:%l" -sourceposition "%line %texfile" %file
	
	Assumptions:
	\begin{enumerate}
	  \item In the multihost networks hosts don't fail.
	  \item The links have tendency to loose and corrupt frames from time to
	  time.
	  \item Frames can arrive out of order.
	  \item The links have varying capacities and MTU.
	  \item Nodes are only aware of their immediate neighbors at the beginning.
	\end{enumerate}
	
\section{Protocol Layers}
Our implementation consists of four layers - Transport, Network
and Datalink. 

\begin{itemize}		
\item	Transport layer: \\
		The purpose of this layer is in buffering incoming and outcoming
		 messages before sending, handling sliding window paradigm, 
		 acknowledgements, resending lost and corrupted fragments.
		
		Services provided by the layer:
    \begin{enumerate}
      \item Reliably delivers a packet from one host to another, avoiding
       packet loss.
      \item Segments the packets to send according to the link MTU.
    \end{enumerate}
		
		Top level API:
  
  \begin{lstlisting}
// initialize transport layer
  void init_transport()
\end{lstlisting}
    
		
		\begin{lstlisting}
// read incoming message from network to transport layer
  void read_transport(uint16_t,char*);
\end{lstlisting}
    
    
    \begin{lstlisting}
// write outcoming message from application into transport layer
  void write_transport(CnetEvent ev, CnetTimerID timer, CnetData data);
\end{lstlisting}
   
			
\item Network layer: \\
		The purpose of this layer is in routing and discovering network,
		 providing the Transport layer with fragmentation and propagation
		 delay information.
		
		Services provided by the layer:
    \begin{enumerate}
      \item Route discovering.
      \item Determines the routing information for a host, by keeping a routing
      table.
      \item Determines lowest MTU on a path from current host to another.
      \item Determines propagation delay for routes.
    \end{enumerate}
		
    Top level API:
		
   \begin{lstlisting}
// initialize network layer
  void init_network()	
\end{lstlisting} 
   
   		
   		\begin{lstlisting}
// detect fragmentation size for the way to specified address
  int get_mtu_for_route(CnetAddr);
\end{lstlisting}
	
	
	\begin{lstlisting}
//get propagation delay for specified address
 int get_propagation_delay(CnetAddr);
\end{lstlisting}
	

\begin{lstlisting}
//write an outcoming packet into network layer
 void write_network(PACKETKIND, CnetAddr,uint16_t, char*);
\end{lstlisting}
	

\begin{lstlisting}
//read an incoming message from datalink to network layer
 void read_network(int link, DATAGRAM dtg, int length);
\end{lstlisting}
	
    	    	
\item	Datalink layer: \\
		The purpose of this layer is in handling Cnet\_write\_physical and
		Cnet\_physical\_ready functions. 
		
		Services provided by the layer:
    \begin{enumerate}
      \item Determines the validity of the received datagram.
      \item Managing output datagram queue for each link 
    \end{enumerate}
		
		Top level API:

    
  \begin{lstlisting}
 //initialize datalink layer
  void init_datalink();
\end{lstlisting}
 
	\begin{lstlisting}
//read an incoming frame into datalink layer
 void read_datalink(CnetEvent event, CnetTimerID timer, CnetData data);
\end{lstlisting}
  

\begin{lstlisting}
//write an outcoming frame into datalink layer
 void write_datalink(int, char *, uint32_t);
\end{lstlisting} 
 


\end{itemize}

\section{Message Packet Datagram}



We define the following basic transfer units: Message, Packet, Datagram, and
Frame. Every unit encapsulates data, which is the unit from the layer above and
header, which is the information added by the current layer. 

\begin{itemize}
  
  \item Packet: \\
  Basic transfer unit of transport layer. 
  
    Data:  a message of application layer
  
    Header:  
  \begin{itemize}
    \item len - the length of the message
    \item dest - the destination address
    \end{itemize}
  
  \item Datagram: \\
   Basic transfer unit of network layer
   
     Data: a packet of transport layer
   
     Header: 
   \begin{itemize}
     \item src (source address)
     \item dest (destination address)
     \item kind (it stands for whether the message is a data 
     \item length (size of the encapsulated data)
     \item checksum (serves for the detection of possible data corruption)
     \item timesent (in microseconds)
     \item payload[MAXFRAMESIZE]
\end{itemize}

 \end{itemize}

\subsection{Fragmentation}

\subsection{Routing}

  \begin{lstlisting} 
  // initialize the routing
extern void init_routing();

// route a packet
extern void route(CnetEvent ev, CnetTimerID timer, CnetData data);

//Check if a route for specified address exists in routing table
extern int is_route_exists(CnetAddr);

//send a route request to find address
extern void send_route_request(CnetAddr);

//process a routing packet
extern void do_routing(int,DATAGRAM);

// learn the routing table
extern void learn_route_table(CnetAddr address, int hops, int link,int mtu,CnetTime total_delay);

// detect a link for outcoming message
extern int get_next_link_for_dest(CnetAddr destaddr);

// detect fragmentation size for the specified address
extern int get_mtu_for_route(CnetAddr);

//get propagation delay for specified address
extern int get_propagation_delay(CnetAddr);

//check if all neighbors were discovered
extern int check_neighbors_discovered();

extern void show_table(CnetEvent ev, CnetTimerID timer, CnetData data);
  \end{lstlisting}

\section{Algorithms}
\begin{itemize}
  \item Routing Algorithm\\
The routing algorithm we implement is based upon the AODV (Ad hoc On-demand
Distance Vector). Every node has links to its neighbours, but is initially
unaware of other nodes in the network. All nodes maintain a routing table 
and a history table. The former includes entries for all destinations already
 discovered by the node. For every disovered destination it also contains 
 the entry for the first neighbour to contact. The latter contains entries 
 for discovery requests that the node has received so far. This serves to 
 discard duplicate requests. Whenever a node needs to send a datagram it first 
 contacts its routing table and in case there is an entry for the destination
 it forwards the datagram to the corresponding link. If the destination is not
 in the routing table then the node broadcasts the request to all its
 neighbours. When a node receives a discovery request it looks it up in its
 history table. If there is an existing entry for this request it is discarded.
 Otherwise if the node knows a path to the destination it sends a reply to the
 destination. If it does not know how to get to destination it increments the hop
 of the request and rebroadcasts it to all its links. Then it adds a new entry to
 its history table which corresponds to the processed request. After a path to
 the destination is discovered reply packets are sent back to the destination
 in the reverse order.
 \end{itemize} 
\section{Summary}

\end{document}